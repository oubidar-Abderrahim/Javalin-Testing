package javalintesting.helloworld;

import io.javalin.Context;
import io.javalin.Javalin;
import javalintesting.entities.Song;

import static io.javalin.apibuilder.ApiBuilder.*;

/**
 * 
 * @author aoubidar
 *
 * check the docs at https://javalin.io/documentation
 */

public class HelloWorld {
	
	public static void main(String[] args) {
		
		Javalin app = Javalin.create().start(7000);
		app.get("/", ctx -> ctx.result("Hello World"));
		app.get("/hello", ctx -> ctx.result("Hello GET as text"));
		app.get("/custom", new CustomHello()); // possible but not recommended
		app.get("/better", HelloWorld::getResponse); // better way to do it
		
		Song song = new Song();
		song.setName("La Tortura");
		song.setArtiste("Shakira");
		song.setFeaturing(new String[] {"Alejandro Sanz"});
		song.setLengthInSeconds(225);
		
		app.get("/song", ctx -> ctx.json(song));
		
		// getting input
		app.get("/:path-param", ctx -> {
			String qp = ctx.queryParam("query-param");
			int integerParam = ctx.validatedQueryParam("index").asInt().getOrThrow(); // getOrThrow throws Exc if it's not int (mapped to http)
			String pp = ctx.pathParam("path-param");
			String fp = ctx.formParam("form-param");
			String body = ctx.body();
			Song songInBody = ctx.bodyAsClass(Song.class);
		});
		
		app.before("/path", ctx -> {
			// do something before req to path, you can use after too (runs even after exception)
			// in case you want it to be after or before all paths, remove the first parameter 
		});
		
		app.exception(NullPointerException.class, (exception, ctx) -> {
			// handel exception here
		});
		
		// webSocket
		app.ws("/websocket/:path", ws -> {
			ws.onConnect(session -> System.out.println("Connected"));
			ws.onMessage((session, message) -> {
		        System.out.println("Received: " + message);
		        session.getRemote().sendString("Echo: " + message);
		    });
		    ws.onClose((session, statusCode, reason) -> System.out.println("Closed"));
		    ws.onError((session, throwable) -> System.out.println("Errored"));
		}); 
		
//		// Configuration possible
		
//		Javalin.create() // create has to be called first
//	    .attribute(Object.class, object) // register an app attribute - since 2.3.0
//	    .attribute(Object.class) // retrieve an app attribute - since 2.3.0
//	    .contextPath("/context-path") // set a context path (default is "/")
//	    .dontIgnoreTrailingSlashes() // treat '/test' and '/test/' as different URLs
//	    .defaultContentType("") // set a default content-type for responses
//	    .disableStartupBanner() // remove the javalin startup banner from logs
//	    .enableCaseSensitiveUrls() // allow urls like '/camelCasedUrl' and match on case
//	    .enableCorsForOrigin("origin") // enables cors for the specified origin(s)
//	    .enableAutogeneratedEtags() // auto-generates etags for get-requests
//	    .enableDebugLogging() // enable extensive debug logging
//	    .enableRouteOverview("/path") // render a HTML page showing all mapped routes
//	    .enableSinglePageMode("path", "filePath") // catch 404s and return file-content as response body
//	    .enableStaticFiles("/public") // enable static files (opt. second param Location.CLASSPATH/Location.EXTERNAL)
//	    .enableWebJars() // enables webjars at /webjars/name/version/file.ext
//	    .disableDynamicGzip() // don't gzip any dynamic responses (static files are still gzipped)
//	    .maxBodySizeForRequestCache(500) // set max body size for request cache
//	    .port(25255) // set the port
//	    .register(extension) // register extension - since 2.5.0
//	    .requestLogger((ctx, timeMs) -> {
//	        System.out.println(ctx.method() + " "  + ctx.path() + " took " + timeMs + " ms");
//	        // prints "GET /hello took 4.5 ms"
//	    }) 
//	    .server(() -> {
//	        Server server = new Server();
//	        // do whatever you want here
//	        return server;
//	    }) 
//	    .sessionHandler() // see section below
//	    .start(); // start the server (has to be called last)
		
		
		
		// this 
		app.get("/users/", HelloWorld::getAll);
		app.post("/users/", HelloWorld::create);
		app.get("/users/:user-id", HelloWorld::getOne);
		app.patch("/users/:user-id", HelloWorld::update);
		app.delete("/users/:user-id", HelloWorld::delete);
		// can be writen using routes like this
		
		app.routes(() -> {
		    path("users", () -> {
		        get(HelloWorld::getAll);
		        post(HelloWorld::create);
		        path(":user-id", () -> {
		            get(HelloWorld::getOne);
		            patch(HelloWorld::update);
//		            delete(HelloWorld::delete);
		        });
		    });
		});
		
	}
	

	private static Context getResponse(Context ctx) {
		
		return ctx.result("Now it's better, and looks geeky");
	}
	private static Context getAll(Context ctx) {
		// get all 
		return ctx.result("Now it's better, and looks geeky");
	}
	private static Context create(Context ctx) {
		// create
		return ctx.result("Now it's better, and looks geeky");
	}
	private static Context getOne(Context ctx) {
		// get with id
		return ctx.result("Now it's better, and looks geeky");
	}
	private static Context update(Context ctx) {
		// update with id
		return ctx.result("Now it's better, and looks geeky");
	}
	private static Context delete(Context ctx) {
		//delete with id
		return ctx;
	}
}
